#!/bin/bash
#
# bandit_bundle - BANDIT functions for bundles
#
# Copyright (C) 2015-2018 Angel Linares Zapater
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as 
# published by the Free Software Foundation. See the COPYING file.
#
# This program is distributed WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
#

source $BANDIT_HOME/bin/bandit_bundle_source
source $BANDIT_HOME/bin/bandit_bundle_package
source $BANDIT_HOME/bin/bandit_bundle_script
source $BANDIT_HOME/bin/bandit_bundle_module
source $BANDIT_HOME/bin/bandit_common

bandit_bundle_do()
{
    local stamp
    bandit_timestamp stamp

    ## Find first catalog and first repository
    if [ $COMMAND != "download" -o $COMMAND != "fetch" ]; then
	# Find first catalog for the bundle
	CATALOG="$(bandit_find_first_catalog_for_bundle)"
	if [ -z $CATALOG ]; then 
	    bandit_exit "BANDIT: Bundle $BUNDLE not found in enabled catalogs list"
	fi
	echo "Working with catalog: $CATALOG"

	# Find first repository for the catalog
	REPOSITORY="$(bandit_find_first_repository_for_catalog)"
	if [ -z $REPOSITORY ]; then 
	    bandit_exit "BANDIT: Catalog $CATALOG not found in repositories list"
	fi
	echo "Working with repository: $REPOSITORY"
    fi

    # Make default directories available to the bundle scripts and origins
    BUILD_BUNDLES=$BANDIT_CATALOGS/$CATALOG/bundles
    BUILD_SCRIPTS=$BANDIT_CATALOGS/$CATALOG/bundles/$BUNDLE.dir
    BUILD_ORIGINS=$BANDIT_CATALOGS/$CATALOG/origins
    BUILD_LOGS=$BANDIT_LOGS/bundles/$BUNDLE.$COMMAND-${stamp}
    BUILD_WORK=$BANDIT_WORK/$BUNDLE-${stamp}

    ## Edit bundle files
    if [ $COMMAND == "edit" ]; then
	ext=""
	case $COMMAND_PARAMS in
	    --conf )
		ext="conf"
		;;
	    --desc )
		ext="desc"
		;;
	    *)
		bandit_exit "BANDIT: Parameter ${COMMAND_PARAMS} not defined for bundle editing"
	esac
	
	${EDITOR:-vi} $BUILD_BUNDLES/$BUNDLE.$ext
    fi

    ## Source bundle configuration files

    # Source bundle description
    if [ -r $BUILD_BUNDLES/$BUNDLE.desc ]; then
	source $BUILD_BUNDLES/$BUNDLE.desc
    else
	bandit_exit "BANDIT: Cannot find $bundle description file"
    fi

    # Source the bundle configuration file
    if [ -r $BUILD_BUNDLES/$BUNDLE.conf ]; then 
    	source $BUILD_BUNDLES/$BUNDLE.conf
    else
	bandit_exit "BANDIT: Cannot find $BUNDLE.conf file"
    fi

    ## Clobber default variables

    # Sources
    BUILD_ORIGIN=$BUILD_ORIGINS/$BUNDLE_ORIGIN
    BUILD_SOURCES=$BANDIT_XSOURCES/$BUNDLE_ORIGIN

    # Build packs
    BUILD_DESTDIR=$BANDIT_XBUILDS/$BUNDLE
    BUILD_RELEASE=${BUNDLE_RELEASE:-$BANDIT_BUILD_RELEASE}

    # Keep or remove *.la files from libtool?
    BUILD_KEEP_LA=${BUNDLE_KEEP_LA:-$BANDIT_BUILD_KEEP_LA}
    
    # Update system databases?
    BUILD_UPDATE_SYSTEM_DB=${BUNDLE_UPDATE_SYSTEM_DB:-$BANDIT_UPDATE_SYSTEM_DB}
   
    ## Create working directories
    bandit_mkdir $BUILD_SOURCES
    bandit_mkdir $BUILD_DESTDIR 
    bandit_mkdir $BUILD_WORK 
    if [ $COMMAND != "download" -a $COMMAND != "fetch" \
       -a $COMMAND != "config" -a $COMMAND != "edit" ]; then 
	bandit_mkdir $BUILD_LOGS
    fi

    ## Build inside work directory
    bandit_pushd $BUILD_WORK

    ## Parse bundle command list by lines
    OLD=$IFS; IFS=$'\n';
    for line in ${BUILD_CMD[*]}; do
	IFS=$OLD
	
	# Parse line into parameters
	words=( $line )

	# Get the item from the command list
	local bundle_item=${words[2]}
	# Take the variant of the item into account
	if [ ${words[4]} ]; then
	   bundle_item=${bundle_item}-${words[4]}
	fi
	# Ignore all other items, when one specific item was selected
	if [ "${ITEM}" != "all" ] && [ "${ITEM}" != "${bundle_item}" ]; then continue; fi

	case $COMMAND in 
	    config)
		bandit_package_do ${words[*]:2}
		;;
	    download | fetch | build | install | raise)
		case ${words[0]} in
		    package)
			case ${words[1]} in
			    do)
				bandit_package_do ${words[*]:2}
				;;
			esac
			;;
		    script)
			if [ $COMMAND == "download" ]; then continue; fi
			if [ $COMMAND == "fetch" ]; then continue; fi
			case ${words[1]} in
			    run) 
				bandit_script_run ${words[*]:2}
				;;
			esac
			;;
		    module)
			if [ $COMMAND == "download" ]; then continue; fi
			if [ $COMMAND == "fetch" ]; then continue; fi
			bandit_module ${words[1]} ${words[*]:2}
			;;
		esac
		;;
	    remove)
		case ${words[0]} in
		    package)
			case ${words[1]} in
			    do)
				bandit_package_do ${words[*]:2}
				;;
			esac
			;;
		    script)
			case ${words[1]} in
			    run) 
				bandit_script_reverse ${words[*]:2}
				;;
			esac
			;;
		    module)
			bandit_module ${words[1]} ${words[*]:2}
			;;
		esac			
		;;
	esac
    done
    IFS=$OLD

    # Return from work directory
    bandit_popd
    
    # Clean work directory
    rm -rf $BUILD_WORK 

    # Update system databases after the bundle work is done
    if [ "$BUILD_UPDATE_SYSTEM_DB" == "yes" ]; then 
	# When the command alters the system databases
	if [ $COMMAND == "install" -o $COMMAND == "raise" -o $COMMAND == "remove" ]; then 
	    # except for the unprivileged 'bandit' user at HOST
	    if [ "$(id -un $UID)" != "$BANDIT_USR" ]; then
		echo 
		echo "Updating system database..."
		[ -x /usr/bin/updatedb ] && updatedb
		echo "Updating man pages database..."
		[ -x /usr/bin/mandb ]    && mandb &> /dev/null
	    fi
	fi
    fi
}
export -f bandit_bundle_do

