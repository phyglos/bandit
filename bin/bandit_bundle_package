#!/bin/bash
#
# bandit_bundle_package - BANDIT functions for bundle packages
#
# Copyright (C) 2015-2016 Àngel Linares Zapater
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as 
# published by the Free Software Foundation. See the COPYING file.
#
# This program is distributed WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
#

#---
# Fetch and prepare functions
#---

bandit_package_get_origins()
{
    # Read the origin file from the catalog
    # URL: list of URLs to fetch from
    # MD5: list of corresponding MD5 cheksums
    # ADD: list of other origins to include in this fetch

    # Get the sources URLs to fetch from
    sources_fetch_url=(${URL[*]})
    sources_fetch_md5=(${MD5[*]})
    # Add other included sources 
    if [ -n $ADD ]; then
	for payload in ${ADD[*]}; do
	    unset URL[*], MD5[*] 2>/dev/null
	    source $catalog/$payload
	    sources_fetch_url=(${sources_fetch_url[*]} ${URL[*]})
	    sources_fetch_md5=(${sources_fetch_md5[*]} ${MD5[*]})
	done
    fi

    # Clean sourced origins variables
    unset URL[*], MD5[*], ADD[*] 2>/dev/null
}

bandit_package_fetch_sources()
{
    # $1 = download -> do not use cache, force download

    let len=${#sources_fetch_url[*]}
    for ((i=0; i<len; i++)); do
	file=$(basename "${sources_fetch_url[i]}")
	
	if [ "$1" == "download" ]; then
	    # Force downloading by removing files in local cache 
	    rm $BUILD_SOURCES/$file{,.md5} 2>/dev/null
	fi

	if [ -r $BUILD_SOURCES/$file ]; then
	    # Fetch from local cache if already exists
	    bandit_msg "...fetching $file from local cache..."

	    # just check for MD5 
	    bandit_md5sum "$BUILD_SOURCES/$file" || bandit_exit
	else
	    case ${sources_fetch_url[i]} in
		file*)
		    # Copy from filesystem
		    bandit_msg "...fetching $file from local filesystem..."
		    cp ${sources_fetch_url[i]#file:}     $BUILD_SOURCES/$file
		    cp ${sources_fetch_url[i]#file:}.md5 $BUILD_SOURCES/$file.md5
		    # Check if MD5 is correct
		    bandit_md5sum "$BUILD_SOURCES/$file" || bandit_exit
		    ;;
		http*)
		    # Download from URL into BUILD_SOURCES
		    bandit_msg "...fetching $file from remote origin..."
		    wget ${sources_fetch_url[i]} \
			 --directory-prefix=$BUILD_SOURCES \
			 --no-verbose \
			 --no-clobber
		    if [[ $? != 0 ]]; then
			bandit_msg "Connection error to ${sources_fetch_url[i]}" red;
		    fi
		    # Check if MD5 is correct
		    echo ${sources_fetch_md5[i]} > $BUILD_SOURCES/$file.md5
		    bandit_md5sum "$BUILD_SOURCES/$file" || bandit_exit
		    ;;
	    esac
	fi

	# Set the tarball
	sources_tarball[i]=$BUILD_SOURCES/$file
    done
}

bandit_package_prepare_sources()
{
    # Custom sources preparation
    if bandit_script_has $catalog/$package sources_prepare; then
	bandit_msg "...preparing sources..."
	# Refactor or rename tarball and payload
	sources_prepare $sources_tarball
    fi

    # Untar main source tarball
    tar -xf ${sources_tarball[0]}
}

bandit_package_fetch_build()
{
    if [ -r $BUILD_DESTDIR/$pack ]; then
	bandit_msg "...fetching $pack from local cache ..."
	bandit_md5sum $BUILD_DESTDIR/$pack || bandit_exit
    else
	bandit_exit "BANDIT: Build $pack not found in local cache"
    fi

    # Create working directory
    bandit_mkdir $package
}

#---
# Package_command functions
#---

bandit_package_config()
{
    ## Configure
    if bandit_script_has $BUILD_SCRIPTS/$script.sh build_config; then  
	bandit_msg "...configuring..."
        build_config
    fi
}

bandit_package_build()
{
    ## Compile 
    if bandit_script_has $BUILD_SCRIPTS/$script.sh build_compile; then  
	bandit_msg "...compiling..."
	bandit_timestamp stamp
        build_compile 2>&1 > $BUILD_LOGS/$script.compile-${stamp}.log
	# Remove unneeded files
	if [ "$BUILD_KEEP_LA" != "yes" ]; then
	    find / -name \*.la -a -not -path "*Image*" -delete
	fi
    fi

    ## Test 
    if (( $BANDIT_BUILD_TEST_LEVEL >= $build_test_level )); then
	if bandit_script_has $BUILD_SCRIPTS/$script.sh build_test; then  
	    bandit_msg "...testing..."
	    bandit_timestamp stamp
	    build_test 2>&1 > $BUILD_LOGS/$script.test-${stamp}.log
	fi
    fi

    ## Pack 
    export BUILD_PACK=$BUILD_DESTDIR/$script
    if bandit_script_has $BUILD_SCRIPTS/$script.sh build_pack; then  
	bandit_msg "...packing..."
	bandit_timestamp stamp
	build_pack 2>&1 > $BUILD_LOGS/$script.pack-${stamp}.log
	bandit_pushd $BUILD_PACK      
	tar -c * | xz -1 > ../$pack
	cd ..
	md5sum -b $pack > $pack.md5
	bandit_popd
    fi
}

bandit_package_install()
{
    ## Install 
    if [ -r $BUILD_DESTDIR/$pack ]; then 
	bandit_msg "...unpacking..."

	# Prefix porg to command, if available (except for the bandit user)
	local CMD=""
	local PRE="eval"
	if [ "$(id -un $UID)" != "$BANDIT_USR" ]; then
	    if [ -e /usr/bin/porg ]; then 
		PRE="porg -lp+ $script"
		# Prefix sudo if available
		if [ -e /usr/bin/sudo ]; then 
		    PRE="sudo "$PRE
		fi
	    fi
	fi
	
	# Unpack
	bandit_timestamp stamp
	( 
	CMD="tar -C / --no-overwrite-dir --keep-directory-symlink -xvf $BUILD_DESTDIR/$pack"    
        ${PRE} "${CMD}"
	if bandit_script_has $BUILD_SCRIPTS/$script.sh install_unpack; then  
	    echo "-----"
	    CMD="install_unpack"
            ${PRE} "${CMD}"
        fi
        ) 2>&1 > $BUILD_LOGS/$script.unpack-${stamp}.log 

	# Make new libraries immediately available (except for the bandit user)
	if [ "$(id -un $UID)" != "$BANDIT_USR" ]; then
	    [ -x /sbin/ldconfig ] && ldconfig
	fi

	## Verify the installed pack
	if bandit_script_has $BUILD_SCRIPTS/$script.sh install_verify; then  
	    bandit_msg "...verifying..."
	    bandit_timestamp stamp
	    install_verify 2>&1 > $BUILD_LOGS/$script.verify-${stamp}.log 
	fi
    fi
}

bandit_package_setup()
{
    ## Set up the installed pack
    if bandit_script_has $BUILD_SCRIPTS/$script.sh install_setup; then  
	bandit_msg "...setting up..."
	bandit_timestamp stamp
	install_setup 2>&1 > $BUILD_LOGS/$script.setup-${stamp}.log 
    fi
}

bandit_package_remove()
{
    bandit_msg "...removing package files..."
    # Log files from porg database and remove the package
    bandit_timestamp stamp
    (
    porg -f $script
    yes | porg -r $script
    ) 2>&1 > $BUILD_LOGS/$script.remove-${stamp}.log 
}

###---
# Package DO
###---

bandit_package_do()
{
    local action=$1   `# Action to perform`
    local option_from_cache=0 
    if [ $2 == "--from-cache" ]; then option_from_cache=1; shift; fi
    local package=$2  `# Package name`
    local tartype=$3  `# Compression type`
    local variant=$4  `# Script variant` 

    bandit_log "$package${variant:+-}$variant [$(date)]"

    # Default functions to be overloaded by the package script
    function sources_prepare() { :; } ; export -f sources_prepare
    function build_config()    { :; } ; export -f build_config
    function build_compile()   { :; } ; export -f build_compile
    function build_test()      { :; } ; export -f build_test
    function build_pack()      { :; } ; export -f build_pack
    function install_unpack()  { :; } ; export -f install_unpack
    function install_verify()  { :; } ; export -f install_verify
    function install_setup()   { :; } ; export -f install_setup
    
    # Default variables to be overloaded by the package script
    local build_test_level=0

    # Source script file name with a possible variant 
    script=$package
    if [ -n "$variant" ]; then
	script=$package-$variant
    fi
    [ -r $BUILD_SCRIPTS/$script.sh ] || bandit_exit "BANDIT: Cannot find $script.sh file"
    source $BUILD_SCRIPTS/$script.sh

    # Source origin file from the catalog directory 
    catalog=$BANDIT_HOME/etc/origins/$BUNDLE_CATALOG/sources 
    [ -r $catalog/$package ] || bandit_exit "BANDIT: No origin $package in catalog $BUNDLE_CATALOG"
    source $catalog/$package

    # Set the build pack name
    pack=${script}-${BANDIT_TARGET_ARCH}-${BUILD_RELEASE}.tar.xz

    # Declare list of package origins
    if [ $option_from_cache == 0 ]; then     
	declare -a sources_fetch_url
	declare -a sources_fetch_md5
    else
	# Sources are already set when --from-cache is used
	:
    fi
    
    # Declare list of package tarball
    declare -a sources_tarball

    case $action in
	download)
	    bandit_package_get_origins
	    bandit_package_fetch_sources download
            bandit_package_prepare_sources
	    ;;
	fetch)
	    bandit_package_get_origins
	    bandit_package_fetch_sources
            bandit_package_prepare_sources
	    ;;
	config)
	    if [ $option_from_cache == 0 ]; then
		# No need to get_origins and fetch
		bandit_package_get_origins
		bandit_package_fetch_sources
	    fi
            bandit_package_prepare_sources
	    bandit_pushd $package
	    bandit_package_config
	    bandit_popd 
	    ;;
	raise)
	    # Copy and mix build and raise options code for bash3 compatibility
	    if [ $option_from_cache == 0 ]; then
		# No need to get_origins and fetch
		bandit_package_get_origins
		bandit_package_fetch_sources
	    fi
	    bandit_package_prepare_sources
	    bandit_pushd $package
	    bandit_package_build
	    bandit_package_install
	    bandit_package_setup
	    bandit_popd 
	    ;;
	build)
	    if [ $option_from_cache == 0 ]; then
		# No need to get_origins and fetch
		bandit_package_get_origins
		bandit_package_fetch_sources
	    fi
	    bandit_package_prepare_sources
	    bandit_pushd $package
	    bandit_package_build
	    bandit_popd 
	    ;;
	install)
	    bandit_package_fetch_build
	    bandit_pushd $package
	    bandit_package_install
	    bandit_package_setup
	    bandit_popd 
	    ;;
	remove)
	    bandit_package_remove
	    ;;
    esac

    # Remove temporary DESTDIR
    rm -rf $BUILD_DESTDIR/$script
    # Remove WORK package directory
    rm -rf $package
}
export -f bandit_package_do

