#!/bin/bash
#
# bandit_bundle_package - BANDIT functions for bundle packages
#
# Copyright (C) 2015-2016 Àngel Linares Zapater
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as 
# published by the Free Software Foundation. See the COPYING file.
#
# This program is distributed WITHOUT ANY WARRANTY; without even the 
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
#

#---
# Fetch and prepare functions
#---

bandit_package_get_origins()
{
    # Read the origin file from the catalog
    # URL: list of URLs to fetch from
    # MD5: list of corresponding MD5 cheksums
    # ADD: list of other origins to include in this fetch

    local catalog=$BANDIT_HOME/etc/origins/$BUNDLE_CATALOG/sources 
    [ -r $catalog/$package ] || bandit_exit "BANDIT: No origin $package in catalog $BUNDLE_CATALOG"
    source $catalog/$package

    # Get the sources URLs to fetch from
    sources_fetch_url=(${URL[*]})
    sources_fetch_md5=(${MD5[*]})
    # Add other included sources 
    if [ -n $ADD ]; then
	for payload in ${ADD[*]}; do
	    unset URL[*], MD5[*] 2>/dev/null
	    source $catalog/$payload
	    sources_fetch_url=(${sources_fetch_url[*]} ${URL[*]})
	    sources_fetch_md5=(${sources_fetch_md5[*]} ${MD5[*]})
	done
    fi

    unset URL[*], MD5[*], ADD[*] 2>/dev/null
}

bandit_package_fetch_sources()
{
# $1 = download -> do not use cache, force download

    let len=${#sources_fetch_url[*]}
    for ((i=0; i<len; i++)); do
	file=$(basename ${sources_fetch_url[i]})

	if [ "$1" == "download" ]; then
	    # Force downloading by removing files in local cache 
	    rm $BUILD_SOURCES/$file{,.md5} 2>/dev/null
	fi

	if [ -r $BUILD_SOURCES/$file ]; then
	    # Fetch from local cache if already exists
	    bandit_msg "...fetching $file from local cache..."

	    # just check for MD5 
	    bandit_md5sum "$BUILD_SOURCES/$file" || bandit_exit
	else
	    # Or download from remote repository
	    bandit_msg "...fetching $file from remote origin..."
 
	    # Download from URL into BUILD_SOURCES
	    wget ${sources_fetch_url[i]} \
		--directory-prefix=$BUILD_SOURCES \
		--no-verbose \
		--no-clobber
	    if [[ $? != 0 ]]; then 
		bandit_msg "Connection error to ${sources_fetch_url[i]}" red; 
	    fi

	    # Check if MD5 is correct
	    echo ${sources_fetch_md5[i]} > $BUILD_SOURCES/$file.md5
	    bandit_md5sum "$BUILD_SOURCES/$file" || bandit_exit
	fi
    done
}

bandit_package_prepare_sources()
{
    local tarball=$(basename ${sources_fetch_url[0]})

    # Untar sources and change into build directory
    # except when just fetching into cache
    if [ $action != "download" ] && [ $action != "fetch" ]; then 
	tar -xf $BUILD_SOURCES/$tarball -C .
    fi
}

bandit_package_fetch_build()
{
    if [ -r $BUILD_DESTDIR/$pack ]; then
	bandit_msg "...fetching $pack from local cache ..."
	bandit_md5sum $BUILD_DESTDIR/$pack || bandit_exit
    else
	bandit_exit "BANDIT: Build $pack not found in local cache"
    fi

    # Create working directory
    bandit_mkdir $package
}

#---
# Package_command functions
#---

bandit_package_config()
{
    ## Configure
    if bandit_script_has $BUILD_SCRIPTS/$script.sh build_config; then  
	bandit_msg "...configuring..."
        build_config
    fi
}

bandit_package_build()
{
    ## Compile 
    if bandit_script_has $BUILD_SCRIPTS/$script.sh build_compile; then  
	bandit_msg "...compiling..."
	bandit_timestamp stamp
        build_compile 2>&1 > $BUILD_LOGS/$script.compile-${stamp}.log
	# Remove unneeded files
	if [ "$BUILD_KEEP_LA" != "yes" ]; then
	    find / -name \*.la -a -not -path "*Image*" -delete
	fi
    fi

    ## Test 
    if (( $BANDIT_BUILD_TEST_LEVEL >= $build_test_level )); then
	if bandit_script_has $BUILD_SCRIPTS/$script.sh build_test; then  
	    bandit_msg "...testing..."
	    bandit_timestamp stamp
	    build_test 2>&1 > $BUILD_LOGS/$script.test-${stamp}.log
	fi
    fi

    ## Pack 
    export BUILD_PACK=$BUILD_DESTDIR/$script
    if bandit_script_has $BUILD_SCRIPTS/$script.sh build_pack; then  
	bandit_msg "...packing..."
	bandit_timestamp stamp
	build_pack 2>&1 > $BUILD_LOGS/$script.pack-${stamp}.log
	bandit_pushd $BUILD_PACK      
	tar -c * | xz -1 > ../$pack
	cd ..
	md5sum -b $pack > $pack.md5
	bandit_popd
    fi
}

bandit_package_install()
{
    ## Install 
    if [ -r $BUILD_DESTDIR/$pack ]; then 
	bandit_msg "...unpacking..."

	# Prefix porg to command, if available (except for the bandit user)
	local CMD=""
	local PRE="eval"
	if [ "$(id -un $UID)" != "$BANDIT_USR" ]; then
	    if [ -e /usr/bin/porg ]; then 
		PRE="porg -lp+ $script"
		# Prefix sudo if available
		if [ -e /usr/bin/sudo ]; then 
		    PRE="sudo "$PRE
		fi
	    fi
	fi
	
	# Unpack
	bandit_timestamp stamp
	( 
	CMD="tar -C / --no-overwrite-dir --keep-directory-symlink -xvf $BUILD_DESTDIR/$pack"    
        ${PRE} "${CMD}"
	if bandit_script_has $BUILD_SCRIPTS/$script.sh install_unpack; then  
	    echo "-----"
	    CMD="install_unpack"
            ${PRE} "${CMD}"
        fi
        ) 2>&1 > $BUILD_LOGS/$script.unpack-${stamp}.log 

	# Make new libraries immediately available (except for the bandit user)
	if [ "$(id -un $UID)" != "$BANDIT_USR" ]; then
	    [ -x /sbin/ldconfig ] && ldconfig
	fi

	## Verify the installed pack
	if bandit_script_has $BUILD_SCRIPTS/$script.sh install_verify; then  
	    bandit_msg "...verifying..."
	    bandit_timestamp stamp
	    install_verify 2>&1 > $BUILD_LOGS/$script.verify-${stamp}.log 
	fi
    fi
}

bandit_package_setup()
{
    ## Set up the installed pack
    if bandit_script_has $BUILD_SCRIPTS/$script.sh install_setup; then  
	bandit_msg "...setting up..."
	bandit_timestamp stamp
	install_setup 2>&1 > $BUILD_LOGS/$script.setup-${stamp}.log 
    fi
}

bandit_package_remove()
{
    bandit_msg "...removing package files..."
    # Log files from porg database and remove the package
    bandit_timestamp stamp
    (
    porg -f $script
    yes | porg -r $script
    ) 2>&1 > $BUILD_LOGS/$script.remove-${stamp}.log 
}

###---
# Package DO, DO_AS, DO_IN functions
###---

bandit_package_do()
{
    local action=$1   `# Action to perform`
    local option_from_cache=0 
    if [ $2 == "--from-cache" ]; then option_from_cache=1; shift; fi
    local package=$2  `# Package name`
    local tartype=$3  `# Compression type`
    local variant=$4  `# Script variant` 

    bandit_log "$package${variant:+-}$variant [$(date)]"

    # Default functions to be overloaded by the package script
    function build_config()    { :; } ; export -f build_config
    function build_compile()   { :; } ; export -f build_compile
    function build_test()      { :; } ; export -f build_test
    function build_pack()      { :; } ; export -f build_pack
    function install_unpack()  { :; } ; export -f install_unpack
    function install_verify()  { :; } ; export -f install_verify
    function install_setup()   { :; } ; export -f install_setup
    
    # Default variables to be overloaded by the package script
    local build_test_level=0

    # Source script file name with a possible variant 
    script=$package
    if [ -n "$variant" ]; then
	script=$package-$variant
    fi
    [ -r $BUILD_SCRIPTS/$script.sh ] || bandit_exit "BANDIT: Cannot find $script.sh file"
    source $BUILD_SCRIPTS/$script.sh

    # Set the build pack name
    pack=${script}-${BANDIT_TARGET_ARCH}-${BUILD_RELEASE}.tar.xz

    # Declare list of package origins
    if [ $option_from_cache == 0 ]; then     
	declare -a sources_fetch_url
	declare -a sources_fetch_md5
    else
	# Sources are already set when --from-cache is used
	:
    fi
    
    case $action in
	download)
	    bandit_package_get_origins
	    bandit_package_fetch_sources download
	    ;;
	fetch)
	    bandit_package_get_origins
	    bandit_package_fetch_sources
	    ;;
	config)
	    if [ $option_from_cache == 0 ]; then
		# No need to get_origins and fetch
		bandit_package_get_origins
		bandit_package_fetch_sources
	    fi
            bandit_package_prepare_sources
	    bandit_pushd $package
	    bandit_package_config
	    bandit_popd 
	    ;;
	raise)
	    # Copy and mix build and raise options code for bash3 compatibility
	    if [ $option_from_cache == 0 ]; then
		# No need to get_origins and fetch
		bandit_package_get_origins
		bandit_package_fetch_sources
	    fi
	    bandit_package_prepare_sources
	    bandit_pushd $package
	    bandit_package_build
	    bandit_package_install
	    bandit_package_setup
	    bandit_popd 
	    ;;
	build)
	    if [ $option_from_cache == 0 ]; then
		# No need to get_origins and fetch
		bandit_package_get_origins
		bandit_package_fetch_sources
	    fi
	    bandit_package_prepare_sources
	    bandit_pushd $package
	    bandit_package_build
	    bandit_popd 
	    ;;
	install)
	    bandit_package_fetch_build
	    bandit_pushd $package
	    bandit_package_install
	    bandit_package_setup
	    bandit_popd 
	    ;;
	remove)
	    bandit_package_remove
	    ;;
    esac

    # Remove temporary DESTDIR
    rm -rf $BUILD_DESTDIR/$script
    # Remove WORK package directory
    rm -rf $package
}
export -f bandit_package_do

bandit_package_do_as()
{
    local action=$1
    local package_new=$2.$3  `# Package alias`
    local package_src=$4     `# Source package name`
    local variant=$5         `# Script variant`

    bandit_log "Doing $package_src as $package_new..."

#TODO: do like package_do_in()
    # Check if tarball exists
#    [ -r $BUILD_SOURCES/$package ] || bandit_exit "BANDIT: $package not found in local cache"
    # Check if MD5 is correct
#    bandit_md5sum "$BUILD_SOURCES/$package" || bandit_exit

    ln -s $BUILD_SOURCES/$package_src     $BUILD_SOURCES/$package_new
    ln -s $BUILD_SOURCES/$package_src.md5 $BUILD_SOURCES/$package_new.md5

    bandit_package_do $action $2 $3 $variant

    rm $BUILD_SOURCES/$package_new{,.md5}
}
export -f bandit_package_do_as

bandit_package_do_in()
{
# Add a top level subdirectory abc, repackage as abc.tmp.tar.xz and start again
# when a package tarball abc.tar.x untars without a top level subdirectory abc.

    local action=$1
    local directory=$2    `# Package directory to create`
    local tarball=$3      `# Package original tarball`
    local variant=$4      `# Script variant`

    local tmpxz=$directory.tmp.tar.xz `# New temporary tarball`

    bandit_log  "Repackaging $tarball content into $tmpxz..."

    # Ignore if just downloading
    if [ $action != "download" ] && [ $action != "fetch" ]; then
	
	# Check if tarball exists
	[ -r $BUILD_SOURCES/$tarball ] || bandit_exit "BANDIT: $tarball not found in local cache"
	# Check if MD5 is correct
	bandit_md5sum "$BUILD_SOURCES/$tarball" || bandit_exit

	# Build a temporary tarball with a base directory named $tarball
	bandit_mkdir $tmpxz
	cd $tmpxz
  	   bandit_mkdir $directory
	   cd $directory
	      tar -xf $BUILD_SOURCES/$tarball
	   cd ..
	   tar -c $directory | xz -0e       > $BUILD_SOURCES/$tmpxz
	   md5sum -b $BUILD_SOURCES/$tmpxz  > $BUILD_SOURCES/$tmpxz.md5
	cd ..
    fi

    # Force to use the new temporary tarball in cache
    sources_fetch_url[0]=$BUILD_SOURCES/$tmpxz
    sources_fetch_md5[0]=$BUILD_SOURCES/$tmpxz.md5
    
    bandit_package_do $action --from-cache $directory tmp.tar.xz $variant

    # Ignore if just downloading
    if [ $action != "download" ] && [ $action != "fetch" ]; then
	# Remove temporary tarball
	rm -rf $tmpxz
	rm $BUILD_SOURCES/$tmpxz{,.md5}
    fi
}
export -f bandit_package_do_in

